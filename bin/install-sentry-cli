#!/usr/bin/env node

const os = require('os');
const fs = require('fs');
const path = require('path');

const HttpsProxyAgent = require('https-proxy-agent');
const fetch = require('node-fetch');
const ProgressBar = require('progress');
const Proxy = require('proxy-from-env');

const USER_AGENT = process.env.npm_config_user_agent || '';
const PACKAGE_VERSION = require('../package.json').version;
const BINARY_PREFIX = '/sentry-cli-';
const CDN_URL =
  process.env.SENTRYCLI_LOCAL_CDNURL ||
  process.env.npm_config_sentrycli_cdnurl ||
  process.env.SENTRYCLI_CDNURL ||
  'https://github.com/getsentry/sentry-cli/releases/download';

function getDownloadUrl(platform, arch) {
  const releasesUrl = CDN_URL + '/' + PACKAGE_VERSION + BINARY_PREFIX;

  switch (platform) {
    case 'darwin':
      return releasesUrl + 'Darwin-x86_64';
    case 'win32':
      return arch.indexOf('64') > -1
        ? releasesUrl + 'Windows-x86_64.exe'
        : releasesUrl + 'Windows-i686.exe';
    case 'linux':
    case 'freebsd':
      return arch.indexOf('64') > -1
        ? releasesUrl + 'Linux-x86_64'
        : releasesUrl + 'Linux-i686';
    default:
      return null;
  }
}

function createProgressBar(name, total) {
  if (process.stdout.isTTY) {
    return new ProgressBar(`fetching ${name} :bar :percent :etas`, {
      complete: '█',
      incomplete: '░',
      width: 20,
      total: total
    });
  }

  if (USER_AGENT.match(/yarn/)) {
    let pct = null;
    let current = 0;
    return {
      tick: length => {
        current += length;
        const next = Math.round(current / total * 100);
        if (next > pct) {
          pct = next;
          process.stdout.write(`fetching ${name} ${pct}%\n`);
        }
      }
    };
  }

  return { tick: () => {} };
}

function writeBinary(input, outputPath, progressBar) {
  const output = fs.createWriteStream(outputPath, { autoClose: true, mode: '0755' });
  return new Promise((resolve, reject) => {
    input.on('data', chunk => progressBar.tick(chunk.length));
    input.on('error', e => reject(e));
    input.pipe(output);

    output.on('error', e => reject(e));
    output.on('closed', () => resolve());
  });
}

function downloadBinary() {
  const arch = os.arch();
  const platform = os.platform();
  const outputPath = path.resolve(
    __dirname,
    platform === 'win32' ? 'sentry-cli.exe' : '../sentry-cli'
  );

  if (fs.existsSync(outputPath)) {
    return;
  }

  const downloadUrl = getDownloadUrl(platform, arch);
  if (!downloadUrl) {
    return Promise.reject(new Error(`unsupported target ${platform}-${arch}`));
  }

  const proxyUrl = Proxy.getProxyForUrl(downloadUrl);
  const agent = proxyUrl ? new HttpsProxyAgent(proxyUrl) : null;
  return fetch(downloadUrl, { redirect: 'follow', agent: agent }).then(response => {
    if (response.status < 200 || response.status >= 300) {
      throw new Error('Received ' + response.status + ': ' + response.statusText);
    }

    const name = downloadUrl.match(/.*\/(.*?)$/)[1];
    const total = parseInt(response.headers.get('content-length'), 10);
    const progressBar = createProgressBar(name, total);
    return writeBinary(response.body, outputPath, progressBar);
  });
}

if (process.env.SENTRYCLI_LOCAL_CDNURL) {
  // For testing, mock the CDN by spawning a local server
  const server = require('http')
    .createServer((request, response) => {
      response.writeHead(200, { 'Content-Type': 'application/octet-stream' });
      var contents = fs.readFileSync(path.join(__dirname, '../js/__mocks__/sentry-cli'));
      response.write(contents);
      response.end();
    })
    .listen(8999);

  process.on('exit', () => server.close());
}

downloadBinary()
  .then(() => process.exit(0))
  .catch(e => {
    console.error(e.toString());
    process.exit(1);
  });
